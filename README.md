# SoftwareTestAndAutomation

* Overview:
Artifacts from my work in software testing, automation, and quality assurance are showcased in this repository. The files from Project One's contact, task, and appointment services as well as Project Two's summary and reflections report are among these artifacts. These files show that I can write unit tests to find bugs, evaluate different software testing methodologies depending on requirements, and implement suitable testing techniques.

* Artifacts:
Contact Service
•	Contact.java
•	ContactService.java
•	ContactTest.java
•	ContactServiceTest.java
Task Service
•	Task.java
•	TaskService.java
•	TaskTest.java
•	TaskServiceTest.java
Appointment Service
•	Appointment.java
•	AppointmentService.java
•	AppointmentTest.java
•	AppointmentServiceTest.java
Project Two: Summary and Reflections Report
•	SummaryAndReflectionsReport.pdf

+ Reflections
- How can I ensure that my code, program, or software is functional and secure?
To ensure my code, program, or software is functional and secure, I follow a rigorous testing approach that includes unit testing, boundary value analysis, and state transition testing. I use JUnit to create thorough test cases that cover both edge cases and core functionalities, achieving over 80% coverage. Additionally, I apply best practices such as methodical setup and teardown procedures and structural assertions to validate the code. Security is addressed by incorporating tests that check for potential vulnerabilities and by adhering to secure coding standards.

- How do I interpret user needs and incorporate them into a program?
Interpreting user needs involves understanding the requirements and ensuring the software aligns with these specifications. For instance, in the ContactService, I ensured that contact IDs were unique, and field validations were met. This alignment with requirements was verified through specific test methods like testAddContact and testUpdateContact. By maintaining close communication with stakeholders and continuously validating the functionality against the requirements, I ensure that the program meets user expectations.

How do I approach designing software?
When designing software, I start with a clear understanding of the requirements and break down the functionality into manageable features. I prioritize writing clean, maintainable code and incorporate automated tests from the beginning to ensure reliability. For example, in the TaskService and AppointmentService, I designed the tests to validate CRUD operations, unique IDs, and field limitations. I also focus on modular design, allowing for scalability and easier maintenance. Additionally, I employ techniques such as equivalency partitioning to classify inputs and ensure comprehensive testing coverage.
Reflection
Writing the JUnit tests for the projects was a methodical process that involved ensuring technical soundness and efficiency. By using techniques such as boundary value analysis and state transition testing, I validated input ranges and boundary conditions. I also recognized the importance of maintaining objectivity and avoiding assumptions during testing. This experience underscored the value of self-discipline in maintaining high-quality standards and preventing technical debt. Overall, the projects have solidified my skills in software testing and reinforced the importance of thorough validation to deliver robust software solutions.
 
Attachments
Please find the complete project files in the attached zip file ProjectOneCS320YancarloGuzman.zip.

